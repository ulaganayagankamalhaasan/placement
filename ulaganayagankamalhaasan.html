<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Code Display</title>
    <style>
        pre {
            background-color: #f4f4f4;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-x: auto;
        }
        code {
            display: block;
            font-family: Consolas, 'Courier New', monospace;
        }
    </style>
</head>
<body>
<h1>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the combined sorted array.</h1>
<pre><code>
        # You are using Python
        def fmosa(m, nums1, n, nums2):
            merged = []
            i, j = 0, 0
            while i < m and j < n:
                if nums1[i] &lt; nums2[j]:
                    merged.append(nums1[i])
                    i += 1
                else:
                    merged.append(nums2[j])
                    j += 1
            merged.extend(nums1[i:])
            merged.extend(nums2[j:])
            total_len = len(merged)
            if total_len % 2 == 1:
                return round(merged[total_len // 2], 1)
            else:
                mid1, mid2 = total_len // 2 - 1, total_len // 2
                return round((merged[mid1] + merged[mid2]) / 2.0, 1)
        
        m = int(input().strip())
        nums1 = list(map(int, input().strip().split()))
        n = int(input().strip())
        nums2 = list(map(int, input().strip().split()))
        median = fmosa(m, nums1, n, nums2)
        print(f"{median:.1f}")
    </code></pre>
<h1>Given a number, find its corresponding Roman numeral.</h1>
<pre><code>
    // You are using Java
    import java.util.*;
    class Roman{
        public static String intoToRoman(int num)
        {
            String roman="";
            int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};
            String[] romanletter={
                "M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
            for(int i=0;i<values.length;i++)
            {
                while(num>=values[i])
                {
                    roman=roman+romanletter[i];
                    num=num-values[i];
                }
            }
            return roman;
        }
        public static void main(String args[])
        {
            Scanner scanner=new Scanner(System.in);
            int num=scanner.nextInt();
            System.out.println("Roman Numeral of Integer is:"+intoToRoman(num));
        }
    }
</code></pre>
<h1>Given an array of string words and a width maxWidth sample output:"[What   must   be, acknowledgment  , shall be        ]"</h1>
<pre><code>
    import java.util.Scanner ;
    import java.util.List ;
    import java.util.ArrayList ;
    
    class Main {
        public static List<String> fullJustify(String[] words, int maxWidth) {
            List<String> res = new ArrayList<>();
            int currSum = 0;    // Current sum of total characters.
            List<String> currList = new ArrayList<>();
            for(int i = 0; i < words.length; i++) {
                if(currSum + words[i].length() + currList.size() <= maxWidth) {
                    currList.add(words[i]);
                    currSum += words[i].length();
                } else {
                    int n = currList.size();    // Number of words in this line.
                    int numSpace = maxWidth - currSum;
                    StringBuffer sb = new StringBuffer();
                    if(n != 1) {
                        int a = numSpace / (n - 1); // Basic number of spaces between words.
                        int b = numSpace - a * (n - 1); // Number of slots which need extra one space.
                        for(int j = 0; j < currList.size(); j++) {
                            sb.append(currList.get(j));
                            if(j < b) {
                                for(int k = 0; k < a + 1; k++)
                                    sb.append(" ");
                            } else if(j != currList.size() - 1) {
                                for(int k = 0; k < a; k++)
                                    sb.append(" ");
                            }
                        }
                    } else {
                        sb.append(currList.get(0));
                        while(sb.length() < maxWidth)
                            sb.append(" ");
                    }
                    res.add(sb.toString());
                    currList = new ArrayList<>();
                    currList.add(words[i]);
                    currSum = words[i].length();
                }
            }
            // For last line.
            if(currList.size() != 0) {
                StringBuffer sb = new StringBuffer();
                for(int i = 0; i < currList.size(); i++) {
                    sb.append(currList.get(i));
                    if(i != currList.size() - 1)
                        sb.append(" ");
                }
                while(sb.length() < maxWidth)
                    sb.append(" ");
                res.add(sb.toString());
            }
            return res;
        }
        public static void main(String a[]) {
            Scanner sc = new Scanner(System.in) ;
            int n = sc.nextInt() ;
            String words[] = new String[n] ;
            for(int i = 0 ; i < n ; i++)
                words[i] = sc.next() ;
            int maxWidth = sc.nextInt() ;
            System.out.print( fullJustify(words, maxWidth).toString() ) ;
        }
    }
</code></pre>
<h1>You have been given three arrays A, B, and C in sorted format. sample output="(6, 15)"</h1>
<pre><code>
    # You are using Python
    import sys
    def findmr(a,b,c):
        pair=()
        diff=sys.maxsize
        for i in range(len(a)):
            for j in range(len(b)):
                for k in range(len(c)):
                    low=min(min(a[i],b[j]),c[k])
                    high=max(max(a[i],b[j]),c[k])
                    if diff>high-low:
                        pair=(low,high)
                        diff=high-low
        return pair
    if __name__=='__main__':
        a=[]
        n=int(input())
        for x in range(0,n):
            ele=int(input())
            a.append(ele)
        b=[]
        n=int(input())
        for x in range(0,n):
            ele=int(input())
            b.append(ele)
        c=[]
        n=int(input())
        for x in range(0,n):
            ele=int(input())
            c.append(ele)
        pair=findmr(a,b,c)
        print(pair)
</code></pre>
<h1>Excel columns are labeled in alphabetical order. i.e. – A, B, C,…AA, BB, CC,…BA, BB, BC,…AAA, AAB, AAC,….AAZ and so on.</h1>
<pre><code>
    def convert(n , base):
    if(n<=base):
        print((chr)(n+64),end="")
        return 
    convert(n//26 , 26) 
    print((chr)(n%26 + 64),end="")
n=int(input())
convert(n , 26) 
</code></pre>
<h1>You have been given a string having space-separated multiple words. sample-output="quick foxjmpslae"</h1>
<pre><code>
    string=input()
    list=[]
    for x in string:
        list.append(x)
    for x in range(0,len(string)):
        for y in range(x+1,len(string)):
           if list[x]==list[y]:
               temp=list[x]
               for i in range(x+1,len(string)):
                   if list[i]==temp:
                       list[i]="temp"
    
    c=0
    for x in list:
        if x=="temp":
            c=c+1
    for v in range(0,c):
        list.remove("temp")
    str=""
    for x in list:
        str+=x
    print(str)             
</code></pre>
<h1>Assume you are the big boss, and you need to choose the house captain for this week,</h1>
<pre><code>
    import java.util.Scanner ;

    class Main
    {
        public static int lastRemaining(int n) 
        {
            boolean left = true;
            int remaining = n;
            int step = 1;
            int head = 1;
            while (remaining > 1) 
            {
                if (left || remaining % 2 ==1) 
                {
                    head = head + step ;
                }
                remaining = remaining / 2;
                step = step * 2;
                left = !left;
            }
            return head ;
        }
        public static void main(String[] args)
        {
            Scanner sc = new Scanner(System.in) ;
            int n = sc.nextInt() ;
            System.out.print(lastRemaining(n)) ;
        }
    }
</code></pre>
<h1>u have been given three arrays A, B, and C in sorted format. sample output="(6,15)"</h1>
<pre><code>
    # You are using Python
    import sys
    def findMinRange(a, b, c):
        pair = ()
        diff = sys.maxsize
        for i in range(len(a)):
            for j in range(len(b)):
                for k in range(len(c)):
                    low = min(min(a[i], b[j]), c[k])
                    high = max(max(a[i], b[j]), c[k])
                    if diff > high - low:
                        pair = (low, high)
                        diff = high - low
        return pair
             
             
    if __name__ == '__main__':
        a=[]
        n=int(input())
        for x in range(0,n):
            ele=int(input())
            a.append(ele)
            
        b=[]
        n=int(input())
        for x in range(0,n):
            ele=int(input())
            b.append(ele)
            
        c=[]
        n=int(input())
        for x in range(0,n):
            ele=int(input())
            c.append(ele)
            
             
        pair = findMinRange(a, b, c)
        print(pair)    
            
</code></pre>
<h1>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the combined sorted array. sampleoutput="2.5"</h1>
<pre><code>
    import java.util.Scanner ;

    class Main{
        
        static double findMedianOfSortedArrays(int nums1[], int m, int nums2[], int n) {
            int N1 = m;
            int N2 = n;
            if (N1 < N2) return findMedianOfSortedArrays(nums2, n, nums1, m);	// Make sure A2 is the shorter one.
        
            int lo = 0, hi = N2 * 2;
            while (lo <= hi) {
                int mid2 = (lo + hi) / 2;   // Try Cut 2 
                int mid1 = N1 + N2 - mid2;  // Calculate Cut 1 accordingly
                
                double L1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[(mid1-1)/2];	// Get L1, R1, L2, R2 respectively
                double L2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[(mid2-1)/2];
                double R1 = (mid1 == N1 * 2) ? Integer.MAX_VALUE : nums1[(mid1)/2];
                double R2 = (mid2 == N2 * 2) ? Integer.MAX_VALUE : nums2[(mid2)/2];
                
                if (L1 > R2) lo = mid2 + 1;		// A1's lower half is too big; need to move C1 left (C2 right)
                else if (L2 > R1) hi = mid2 - 1;	// A2's lower half too big; need to move C2 left.
                else return (Math.max(L1,L2) + Math.min(R1, R2)) / 2;	// Otherwise, that's the right cut.
            }
            return -1 ;
        }   
        
        public static void main(String a[]){
            Scanner sc = new Scanner(System.in);
            int m = sc.nextInt() ;
            int nums1[] = new int [m] ;
            for(int i = 0 ; i < m ; i++)
                nums1[i] = sc.nextInt() ;
            int n = sc.nextInt() ;
            int nums2[] = new int[n] ;
            for(int i = 0 ; i < n ; i++)
                nums2[i] = sc.nextInt() ;
                
            System.out.print(findMedianOfSortedArrays(nums1, m, nums2, n));
        }
    }
</code></pre>
<h1>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: output:false</h1>
<pre><code>
    def isMatch(s, p):
    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
    dp[0][0] = True
    for i in range(1, len(p) + 1):
        dp[0][i] = dp[0][i - 1] and (p[i - 1] == '*')

    for i in range(1, len(s) + 1):
        for j in range(1, len(p) + 1):
            if p[j - 1] != '*':
                if p[j - 1] == '?' or p[j - 1] == s[i - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
    return str(dp[len(s)][len(p)]).lower()

if __name__ == "__main__":
    s = input()
    p = input()
    print(isMatch(s, p), end="")
</code></pre>
<h1>When a particular range is given to Kyle, he writes down all the values within that range which consists of unique digits.</h1>
<pre><code>
    #include <stdio.h>
        #include <math.h>
        
        
        int unique_digit(int n)
        {
            int a[10] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
            int r, pos = 0;
            while (n)
            {
                r = n % 10;
        
                if (a[r] == -1)
                    a[r] = pos;
                else
                    return a[r];
        
                pos++;
                n /= 10;
            }
            return -1;
        }
        
        int main()
        {
            int pos, st, end, i, x, y;
            scanf("%d %d", &st, &end);
            for (i = st; i <= end; ++i)
            {
                pos = unique_digit(i);
                if (pos == -1)
                {
                    printf("%d ", i);
                    continue;
                }
                else if (pos == 0)
                {
                    continue;
                }
        
               
        
                x = pow(10, pos);
                y = i % x;
        
                i = i + (x - y) - 1; 
            }
            return 0;
        }
        
</code></pre>
<h1>Given an array A of size N that contains only non-negative integers, find a continuous sub-array that adds to a given number S and return the left and right indexes of that sub-array. In the case of multiple subarrays, return the subarray indexes that come first when moving from left to right. output:2 4
</h1>
<pre><code>
    #include <iostream>
        using namespace std;
        
        void subarraySum(int arr[], int n, int s, int &start, int &end) {
            int sum = 0;
            start = 0;
            end = -1;
            int i = 0, st = 0;
        
            while (i < n) {
                sum += arr[i];
        
                while (sum > s) {
                    sum -= arr[st];
                    st++;
                }
        
                if (sum == s) {
                    start = st + 1;
                    end = i + 1;
                    return;
                }
                i++;
            }
        }
        
        int main() {
            int l, sum;
            cin >> l;
            int arr[l];
            cin >> sum;
            for (int i = 0; i < l; i++) {
                cin >> arr[i];
            }
        
            int start = 0, end = -1;
            subarraySum(arr, l, sum, start, end);
        
            if (end == -1) {
                cout << "-1";
            } else {
                cout << start << " " << end;
            }
            return 0;
        }
</code></pre>
<h1>Preethi was fond of programming. One day she attended a hackathon where she came across a question. output: 2</h1>
<pre><code>
    import java.util.*;
    class Main 
    {
        static int countDigitOccurrences(int l, int u, int x)
        {
            int rem, count = 0;
            for(int i = l; i <= u; i++)
            {
                int temp = i;
                while(temp != 0 )
                {
                    if(temp % 10 == x)
                        count++;
                    temp = temp / 10;
                }
            }
            return count;
        }
        
        public static void main(String args[])
        {
            Scanner sc = new Scanner(System.in);
            int l = sc.nextInt();
            int u = sc.nextInt();
            int x = sc.nextInt();
            System.out.print(countDigitOccurrences(l, u, x));
        }
    }
</code></pre>
<h1>You are given an array of integers. Your task is to find the longest subarray in which the elements are first sorted in increasing order and then in decreasing order. output 7
    -4 5 6 8 9 7 -5 </h1>
<pre><code>
    # You are using Python
    def find_longest_bitonic_subarray(arr):
        n = len(arr)
        if n == 1:
            return 1, arr
            
        inc = [1] * n
        dec = [1] * n
            
        for i in range(1,n):
            if arr[i] > arr[i - 1]:
                inc[i] = inc[i - 1] + 1
            
        for i in range(n-2, -1, -1):
            if arr[i] > arr[i + 1]:
                dec[i] = dec[i + 1] + 1
                    
        max_len = 0
        start_index = 0
            
        for i in range(n):
            current_len = inc[i] + dec[i] - 1
            if current_len > max_len:
                max_len = current_len
                start_index = i - inc[i] + 1
                
        bitonic_subarray = arr[start_index : start_index + max_len]
            
        return max_len, bitonic_subarray
    
    n = int(input())
    arr = list(map(int, input().split()))
    
    length, subarray = find_longest_bitonic_subarray(arr)
    print(length)
    print(" ".join(map(str, subarray)))
</code></pre>
<h1>You are given a string s consisting of only lowercase English letters. input:abcabcdabc output:2</h1>
<pre><code>
    import java.util.Scanner;
    class Solution {
        int base = 131;
        long[] p; // power of base
        long[] h; // hash value
        
        private long get(int l, int r) {
            return h[r] - h[l - 1] * p[r - l + 1];
        }
        
        public int deleteString(String s) {
            int n = s.length();
            // add padding for 0
            p = new long[n + 2];
            h = new long[n + 2];
            
            p[0] = 1;
            for (int i = 1; i <= n; i++) {
                p[i] = p[i - 1] * base;
                h[i] = h[i - 1] * base + s.charAt(i - 1);
            }
            
            int[] dp = new int[n + 2];
            for (int i = n; i > 0; i--) {
                dp[i] = 1;
                for (int len = 1; len <= (n - i + 1) / 2; len++) {
                    if (get(i, i + len - 1) == get(i + len, i + 2 * len - 1)) {
                        dp[i] = Math.max(dp[i], dp[i + len] + 1);
                    }
                }
            }
            
            return dp[1];
        }
    }
    public class Main{
        public static void main(String args[])
        {
            Scanner sc=new Scanner(System.in);
            Solution sln=new Solution();
            String str=sc.nextLine(); 
            System.out.println(sln.deleteString(str));
        }
    }
</code></pre>
<h1>A valid number can be split up into these components (in order): output:true</h1>
<pre><code>
    import java.util.Scanner ;

    class Solution {
        public static boolean isNumber(String s) {
            try{
                Double x = Double.parseDouble(s); //is this possible?
            }catch(NumberFormatException e){ //no return false
                return false;
            }finally{
                if (s.matches(".*[a-dA-D].*") || s.matches(".*[f-zF-Z].*")) { 
                        return false; //maybe check if it does contain a character              other than e
                }
            }  
        return true;
        }
        public static void main(String a[]){
            Scanner sc = new Scanner(System.in) ;
            String s = sc.next() ;
            System.out.print(isNumber(s)) ;
        }
    }
</code></pre>
<h1></h1>
<pre><code>

</code></pre>
<h1></h1>
<pre><code>

</code></pre>
<h1></h1>
<pre><code>

</code></pre>
</body>
</html>